#!/bin/bash

# Ubuntu Iranian Mirror Changer Script
# Fixed version with comprehensive error handling and security improvements

echo "üî∏ Ubuntu Mirror Changer - Replacing default Ubuntu mirrors with Iranian mirrors"
echo "‚ö†Ô∏è  If you have package download issues, changing download servers can be a solution."
echo

# Iranian mirror list (duplicates removed, URLs normalized, verified working mirrors)
MIRRORS=(
    "https://mirror.iranserver.com/ubuntu"
    "https://mirrors.pardisco.co/ubuntu"
    "http://mirror.aminidc.com/ubuntu"
    "http://mirror.faraso.org/ubuntu"
    "https://ir.ubuntu.sindad.cloud/ubuntu"
    "https://ubuntu-mirror.kimiahost.com"
    "https://archive.ubuntu.petiak.ir/ubuntu"
    "https://ubuntu.hostiran.ir/ubuntuarchive"
    "https://ubuntu.bardia.tech"
    "https://ir.archive.ubuntu.com/ubuntu"
    "https://mirror.0-1.cloud/ubuntu"
    "http://linuxmirrors.ir/pub/ubuntu"
    "http://repo.iut.ac.ir/repo/Ubuntu"
    "https://ubuntu.shatel.ir/ubuntu"
    "http://ubuntu.byteiran.com/ubuntu"
    "https://mirror.rasanegar.com/ubuntu"
)

# Default mirror
DEFAULT_MIRROR="http://archive.ubuntu.com/ubuntu"

# Global variables
selected_mirror=""
SUDO_CMD=""
BACKUP_FILE=""

# Check if running as root
check_root() {
    if [[ $EUID -eq 0 ]]; then
        echo "‚ö†Ô∏è  Running as root user detected."
        SUDO_CMD=""
    else
        SUDO_CMD="sudo"
        
        # Check if user can sudo
        if ! sudo -n true 2>/dev/null; then
            echo "üîê This script requires sudo privileges to modify system files."
            echo "   Please ensure you can run sudo commands."
        fi
    fi
}

# Check if running as root
check_root() {
    if [[ $EUID -eq 0 ]]; then
        echo "‚ö†Ô∏è  Running as root user detected."
        SUDO_CMD=""
    else
        SUDO_CMD="sudo"
    fi
}

# Function to validate URL format
validate_url() {
    local url="$1"
    
    # Basic URL validation
    if [[ ! "$url" =~ ^https?://[a-zA-Z0-9.-]+(/.*)?$ ]]; then
        return 1
    fi
    
    return 0
}

# Function to normalize URL (remove trailing slash)
normalize_url() {
    local url="$1"
    echo "${url%/}"
}

# Function to backup current sources.list safely
backup_sources() {
    echo "üîπ Backing up current sources.list..."
    
    # Check if sources.list exists and is readable
    if [ ! -f "/etc/apt/sources.list" ]; then
        echo "‚ùå /etc/apt/sources.list not found!"
        return 1
    fi
    
    if [ ! -r "/etc/apt/sources.list" ]; then
        echo "‚ùå Cannot read /etc/apt/sources.list!"
        return 1
    fi
    
    # Create backup with timestamp if one already exists
    local backup_file="/etc/apt/sources.list.bak"
    if [ -f "$backup_file" ]; then
        local timestamp=$(date +%Y%m%d_%H%M%S)
        backup_file="/etc/apt/sources.list.bak.${timestamp}"
        echo "üìù Previous backup exists, creating new backup: $backup_file"
    fi
    
    if $SUDO_CMD cp /etc/apt/sources.list "$backup_file"; then
        echo "‚úÖ Backup created at $backup_file"
        # Set global variable for restore function
        BACKUP_FILE="$backup_file"
        return 0
    else
        echo "‚ùå Failed to create backup!"
        return 1
    fi
}

# Function to create new sources.list with selected mirror (secure version)
create_sources_list() {
    local mirror_url="$1"
    echo "üîπ Creating new sources.list with mirror: $mirror_url"
    
    # Normalize URL and validate
    mirror_url=$(normalize_url "$mirror_url")
    if ! validate_url "$mirror_url"; then
        echo "‚ùå Invalid mirror URL format!"
        return 1
    fi
    
    # Get Ubuntu codename with error handling
    local codename
    if ! codename=$(lsb_release -sc 2>/dev/null); then
        echo "‚ùå Failed to get Ubuntu codename!"
        return 1
    fi
    
    # Validate codename
    if [[ -z "$codename" || ! "$codename" =~ ^[a-z]+$ ]]; then
        echo "‚ùå Invalid Ubuntu codename: '$codename'"
        return 1
    fi
    
    echo "üìã Ubuntu codename: $codename"
    
    # Create temporary file for atomic operation
    local temp_sources
    if ! temp_sources=$(mktemp); then
        echo "‚ùå Failed to create temporary file!"
        return 1
    fi
    
    # Generate sources.list content safely
    cat > "$temp_sources" << EOF
# Generated by Ubuntu Mirror Changer
# Mirror: $mirror_url
# Ubuntu codename: $codename
# Generated on: $(date)

# Main repositories
deb $mirror_url/ $codename main restricted universe multiverse
deb $mirror_url/ $codename-updates main restricted universe multiverse
deb $mirror_url/ $codename-backports main restricted universe multiverse
deb $mirror_url/ $codename-security main restricted universe multiverse

# Source repositories (uncomment if needed)
# deb-src $mirror_url/ $codename main restricted universe multiverse
# deb-src $mirror_url/ $codename-updates main restricted universe multiverse
# deb-src $mirror_url/ $codename-backports main restricted universe multiverse
# deb-src $mirror_url/ $codename-security main restricted universe multiverse
EOF
    
    # Verify the temp file was created correctly
    if [ ! -s "$temp_sources" ]; then
        echo "‚ùå Failed to generate sources.list content!"
        rm -f "$temp_sources"
        return 1
    fi
    
    # Atomically replace the sources.list
    if $SUDO_CMD mv "$temp_sources" /etc/apt/sources.list; then
        echo "‚úÖ New sources.list created successfully"
        return 0
    else
        echo "‚ùå Failed to install new sources.list"
        rm -f "$temp_sources"
        return 1
    fi
}

# Function to update package list with timeout and retry
update_packages() {
    echo "üîπ Updating package list..."
    local max_attempts=2
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        echo "   Attempt $attempt/$max_attempts..."
        
        if timeout 300 $SUDO_CMD apt update 2>/dev/null; then
            echo "‚úÖ Package list updated successfully"
            return 0
        else
            echo "‚ùå Failed to update package list (attempt $attempt/$max_attempts)"
            if [ $attempt -lt $max_attempts ]; then
                echo "   Retrying in 3 seconds..."
                sleep 3
            fi
            ((attempt++))
        fi
    done
    
    echo "‚ùå Failed to update package list after $max_attempts attempts"
    return 1
}

# Function to restore backup safely
restore_backup() {
    echo "üîπ Restoring backup..."
    
    # Use the specific backup file if set, otherwise try default
    local backup_file="${BACKUP_FILE:-/etc/apt/sources.list.bak}"
    
    if [ -f "$backup_file" ]; then
        if $SUDO_CMD cp "$backup_file" /etc/apt/sources.list; then
            echo "‚úÖ Backup restored successfully from $backup_file"
            return 0
        else
            echo "‚ùå Failed to restore backup from $backup_file!"
            return 1
        fi
    else
        echo "‚ùå No backup found at $backup_file!"
        return 1
    fi
}

# Function to show mirror selection menu
show_mirror_menu() {
    echo "üîπ Available Iranian mirrors:"
    echo "0) Use default mirror (${DEFAULT_MIRROR})"
    for i in "${!MIRRORS[@]}"; do
        echo "$((i+1))) ${MIRRORS[$i]}"
    done
    echo "$((${#MIRRORS[@]}+1))) Enter custom mirror URL"
    echo "$((${#MIRRORS[@]}+2))) üéØ Smart Pick (Auto-select best working mirror)"
    echo
}

# Function to test mirror connectivity and repository structure
test_mirror() {
    local mirror_url="$1"
    local quiet="${2:-false}"
    local timeout="${3:-15}"
    
    [[ "$quiet" == "false" ]] && echo "Testing connectivity to: $mirror_url"
    
    # Normalize URL for testing
    local test_url=$(normalize_url "$mirror_url")
    
    # Test 1: Basic connectivity
    if ! curl -s --connect-timeout "$timeout" --max-time "$((timeout * 2))" --head "$test_url" > /dev/null 2>&1; then
        [[ "$quiet" == "false" ]] && echo "‚ùå Mirror is not accessible (connection failed)"
        return 1
    fi
    
    # Test 2: Check if it's actually an Ubuntu repository
    if ! curl -s --connect-timeout "$timeout" --max-time "$((timeout * 2))" "${test_url}/ls-lR.gz" > /dev/null 2>&1 && \
       ! curl -s --connect-timeout "$timeout" --max-time "$((timeout * 2))" "${test_url}/dists/" > /dev/null 2>&1; then
        [[ "$quiet" == "false" ]] && echo "‚ùå Mirror is accessible but doesn't appear to be an Ubuntu repository"
        return 1
    fi
    
    # Test 3: Check if the mirror supports current Ubuntu version
    local codename
    if codename=$(lsb_release -sc 2>/dev/null) && [[ -n "$codename" ]]; then
        if ! curl -s --connect-timeout "$timeout" --max-time "$((timeout * 2))" "${test_url}/dists/${codename}/" > /dev/null 2>&1; then
            [[ "$quiet" == "false" ]] && echo "‚ö†Ô∏è  Mirror accessible but may not support Ubuntu $codename"
            # Don't fail completely, just warn
        fi
    fi
    
    [[ "$quiet" == "false" ]] && echo "‚úÖ Mirror is accessible and appears to be a valid Ubuntu repository"
    return 0
}

# Function to smart pick the best working mirror
smart_pick_mirror() {
    echo "üîç Smart Pick: Testing all mirrors to find the best working one..."
    echo "This may take a moment..."
    echo
    
    local working_mirrors=()
    local total_mirrors=$((${#MIRRORS[@]} + 1))
    local current=0
    
    # Test default mirror first
    current=$((current + 1))
    echo "[$current/$total_mirrors] Testing default mirror: $DEFAULT_MIRROR"
    if test_mirror "$DEFAULT_MIRROR" "true"; then
        working_mirrors+=("$DEFAULT_MIRROR")
        echo "‚úÖ Default mirror is working"
    else
        echo "‚ùå Default mirror failed"
    fi
    echo
    
    # Test all other mirrors
    for mirror in "${MIRRORS[@]}"; do
        current=$((current + 1))
        echo "[$current/$total_mirrors] Testing: $mirror"
        if test_mirror "$mirror" "true"; then
            working_mirrors+=("$mirror")
            echo "‚úÖ Mirror is working"
        else
            echo "‚ùå Mirror failed"
        fi
        echo
    done
    
    # Show results
    if [ ${#working_mirrors[@]} -eq 0 ]; then
        echo "üòû No working mirrors found!"
        echo "You may want to check your internet connection or try again later."
        return 1
    else
        echo "üéâ Found ${#working_mirrors[@]} working mirror(s):"
        for i in "${!working_mirrors[@]}"; do
            echo "$((i+1)). ${working_mirrors[$i]}"
        done
        echo
        
        # Use the first working mirror
        selected_mirror="${working_mirrors[0]}"
        echo "üéØ Selected: $selected_mirror"
        return 0
    fi
}

# Function to get custom mirror URL with comprehensive validation
get_custom_mirror() {
    local max_attempts=3
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        echo "üìù Enter custom mirror URL (attempt $attempt/$max_attempts):"
        echo "   Example: https://your-mirror.com/ubuntu"
        read -p "URL: " custom_url
        
        # Basic input validation
        if [[ -z "$custom_url" ]]; then
            echo "‚ùå Empty URL provided!"
            ((attempt++))
            continue
        fi
        
        # Validate URL format
        if ! validate_url "$custom_url"; then
            echo "‚ùå Invalid URL format! Please enter a valid HTTP/HTTPS URL."
            echo "   Example: https://mirror.example.com/ubuntu"
            ((attempt++))
            continue
        fi
        
        # Test the custom mirror
        echo "üîç Testing custom mirror..."
        if test_mirror "$custom_url" "false" 20; then
            selected_mirror="$custom_url"
            echo "‚úÖ Custom mirror validated successfully!"
            return 0
        else
            echo "‚ö†Ô∏è  Custom mirror is not accessible or invalid."
            echo "1) Try a different URL"
            echo "2) Use this URL anyway (not recommended)"
            echo "3) Go back to mirror selection"
            
            read -p "Select option (1-3): " choice
            case "$choice" in
                "1")
                    ((attempt++))
                    continue
                    ;;
                "2")
                    echo "‚ö†Ô∏è  Using potentially problematic mirror..."
                    selected_mirror="$custom_url"
                    return 0
                    ;;
                "3")
                    return 1
                    ;;
                *)
                    echo "‚ùå Invalid option! Trying again..."
                    ((attempt++))
                    ;;
            esac
        fi
    done
    
    echo "‚ùå Maximum attempts reached. Returning to mirror selection."
    return 1
}

# Function to handle mirror selection
select_mirror() {
    while true; do
        show_mirror_menu
        
        # Get user selection
        read -p "Select mirror (0-$((${#MIRRORS[@]}+2))): " selection
        
        case "$selection" in
            "0")
                selected_mirror="$DEFAULT_MIRROR"
                return 0
                ;;
            "$((${#MIRRORS[@]}+1))")
                if get_custom_mirror; then
                    return 0
                fi
                # If custom mirror selection failed, continue loop
                ;;
            "$((${#MIRRORS[@]}+2))")
                # Smart Pick option
                if smart_pick_mirror; then
                    echo "‚úÖ Smart Pick completed successfully"
                    return 0
                else
                    echo "‚ùå Smart Pick failed to find any working mirrors"
                    echo "Please try selecting a mirror manually."
                    echo
                fi
                ;;
            *)
                # Check if selection is a valid mirror index
                if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 && "$selection" -le "${#MIRRORS[@]}" ]]; then
                    selected_mirror="${MIRRORS[$((selection-1))]}"
                    return 0
                else
                    echo "‚ùå Invalid selection! Please enter a number between 0 and $((${#MIRRORS[@]}+2))."
                    echo
                fi
                ;;
        esac
    done
}

# Function to handle mirror testing and retry options
handle_mirror_test() {
    echo "Selected mirror: $selected_mirror"
    
    # Test mirror connectivity (skip for Smart Pick as it's already tested)
    if [[ "$selected_mirror" != *"Smart Pick"* ]]; then
        if ! test_mirror "$selected_mirror"; then
            while true; do
                echo "‚ö†Ô∏è  Mirror seems to be inaccessible. What would you like to do?"
                echo "1) Continue anyway"
                echo "2) Try another mirror"
                echo "3) Exit and restore backup"
                echo
                read -p "Select option (1-3): " mirror_choice
                
                case "$mirror_choice" in
                    "1")
                        echo "Continuing with inaccessible mirror..."
                        return 0
                        ;;
                    "2")
                        echo
                        if select_mirror; then
                            # Recursive call to test the new selection
                            if handle_mirror_test; then
                                return 0
                            fi
                        else
                            echo "‚ùå Mirror selection failed! Returning to options..."
                        fi
                        ;;
                    "3")
                        echo "Exiting and restoring backup..."
                        restore_backup
                        exit 0
                        ;;
                    *)
                        echo "‚ùå Invalid option! Please select 1, 2, or 3."
                        ;;
                esac
            done
        fi
    fi
    
    return 0
}

# Function to check system requirements and dependencies
check_requirements() {
    local missing_deps=()
    local missing_commands=()
    
    echo "üîç Checking system requirements..."
    
    # Check for required commands
    local required_commands=("lsb_release" "curl" "apt" "mktemp")
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_commands+=("$cmd")
            case "$cmd" in
                "lsb_release")
                    missing_deps+=("lsb-release")
                    ;;
                "curl")
                    missing_deps+=("curl")
                    ;;
            esac
        fi
    done
    
    # Check if we're on Ubuntu/Debian-based system
    if [ ! -f "/etc/apt/sources.list" ]; then
        echo "‚ùå This script is designed for Ubuntu/Debian systems with APT package manager."
        echo "   /etc/apt/sources.list not found!"
        return 1
    fi
    
    # Check if sources.list is writable
    if [ ! -w "$(dirname /etc/apt/sources.list)" ]; then
        echo "‚ùå Cannot write to /etc/apt/ directory. Please run with appropriate permissions."
        return 1
    fi
    
    # Check system architecture
    local arch
    if ! arch=$(dpkg --print-architecture 2>/dev/null); then
        echo "‚ö†Ô∏è  Warning: Could not determine system architecture."
    else
        echo "üìã System architecture: $arch"
    fi
    
    # Install missing dependencies if any
    if [ ${#missing_deps[@]} -gt 0 ]; then
        echo "üì¶ Installing missing dependencies: ${missing_deps[*]}"
        echo "   This requires an internet connection and working package manager..."
        
        if ! $SUDO_CMD apt update -qq && $SUDO_CMD apt install -y "${missing_deps[@]}"; then
            echo "‚ùå Failed to install required dependencies!"
            echo "   Please install manually: ${missing_deps[*]}"
            return 1
        fi
        
        echo "‚úÖ Dependencies installed successfully"
    fi
    
    # Verify all commands are now available
    for cmd in "${missing_commands[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            echo "‚ùå Required command '$cmd' is still not available after dependency installation!"
            return 1
        fi
    done
    
    # Check Ubuntu version compatibility
    local version_id
    if version_id=$(lsb_release -rs 2>/dev/null); then
        echo "üìã Ubuntu version: $version_id"
        
        # Warn about EOL versions
        case "$version_id" in
            "14.04"|"16.04"|"17."*|"18.10"|"19."*|"20.10"|"21."*)
                echo "‚ö†Ô∏è  Warning: You're using an older Ubuntu version ($version_id)."
                echo "   Some mirrors may not support this version."
                ;;
        esac
    fi
    
    return 0
}

# Main script execution
main() {
    echo "Starting Ubuntu Mirror Changer..."
    echo
    
    # Check if running as root
    check_root
    
    # Check system requirements
    if ! check_requirements; then
        exit 1
    fi
    
    # Backup current sources.list
    if ! backup_sources; then
        exit 1
    fi
    
    # Select mirror
    if ! select_mirror; then
        echo "‚ùå Mirror selection failed!"
        restore_backup
        exit 1
    fi
    
    # Handle mirror testing
    if ! handle_mirror_test; then
        echo "‚ùå Mirror testing failed!"
        restore_backup
        exit 1
    fi
    
    # Create new sources.list with selected mirror
    if ! create_sources_list "$selected_mirror"; then
        echo "‚ùå Failed to create new sources.list"
        restore_backup
        exit 1
    fi
    
    # Update package list
    echo "üîÑ Testing the new mirror configuration..."
    if ! update_packages; then
        echo "‚ùå Failed to update with selected mirror. Restoring backup..."
        restore_backup
        if update_packages; then
            echo "‚úÖ Original configuration restored and working"
        fi
        echo "‚ö†Ô∏è  Mirror change failed. The selected mirror may not be compatible with your Ubuntu version."
        exit 1
    fi
    
    echo
    echo "üéâ Mirror successfully changed to: $selected_mirror"
    echo "‚úÖ Package list updated successfully"
    echo "üìã Your original sources.list has been backed up to /etc/apt/sources.list.bak"
    echo
    echo "To restore original settings later, run:"
    echo "sudo mv /etc/apt/sources.list.bak /etc/apt/sources.list && sudo apt update"
    echo
    echo "Happy package installing! üöÄ"
}

# Enhanced cleanup function
cleanup_on_exit() {
    local exit_code=$?
    
    if [ $exit_code -ne 0 ]; then
        echo
        echo "üõë Script interrupted or failed (exit code: $exit_code)"
        
        if [ -n "$BACKUP_FILE" ] && [ -f "$BACKUP_FILE" ]; then
            echo "üîÑ Attempting to restore backup..."
            if restore_backup; then
                echo "‚úÖ System restored to original state"
            else
                echo "‚ùå Failed to restore backup! Manual intervention may be required."
                echo "   Backup location: $BACKUP_FILE"
            fi
        fi
    fi
}

# Enhanced signal handling
trap cleanup_on_exit EXIT
trap 'echo -e "\nüõë Script interrupted by user!"; exit 130' INT TERM

# Run main function
main "$@"
